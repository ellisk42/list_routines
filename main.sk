include "language.skh";
pragma options "--bnd-unroll-amnt 4 --bnd-arr1d-size 4 --bnd-arr-size 4 --bnd-inline-amnt 4";

#define FIRSTNUMBER
#define SECONDNUMBER

Array recursive_list([int nz,int na], int [nz] numbers, Array[na] arrays, int bound) {
  int cost = 0;
  bit additionalBaseCase = ??;
  bit additionalRecursive = ??;

  BooleanExpression predicate = sampleBooleanExpression(UNROLL);
  ListExpression baseCase = sampleListExpression(UNROLL);
  cost += booleanCost(predicate) + listCost(baseCase);

  BooleanExpression predicate2;
  ListExpression baseCase2;
  if (additionalBaseCase) {
    predicate2 = sampleBooleanExpression(UNROLL);
    baseCase2 = sampleListExpression(UNROLL);
    cost += booleanCost(predicate2) + listCost(baseCase2);
  }  
#ifdef FIRSTNUMBER
  NumberExpression newNumber1 = sampleNumberExpression(UNROLL);
  cost += numberCost(newNumber1);
#endif
#ifdef SECONDNUMBER
  NumberExpression newNumber2 = sampleNumberExpression(UNROLL);
  cost += numberCost(newNumber2);
#endif
  ListExpression newList = sampleListExpression(UNROLL);
  ListExpression returnValue = sampleListExpression(UNROLL);
  cost += listCost(newList) + listCost(returnValue);

  minimize(cost);
  
  if (evaluateBoolean(predicate, numbers, arrays)) {
    return evaluateList(baseCase, numbers, arrays);
  }

  if (additionalBaseCase) {
    if (evaluateBoolean(predicate2, numbers, arrays)) {
      return evaluateList(baseCase2, numbers, arrays);
    }
  }

  if (bound < 1) { assert 0; return null; }

  int [nz] numberArguments = {
#ifdef FIRSTNUMBER
    evaluateNumber(newNumber1, numbers, arrays)
#endif
#ifdef SECONDNUMBER			      
			      , evaluateNumber(newNumber2, numbers, arrays)
#endif
  };
  
  Array r = recursive_list(numberArguments,
			   {evaluateList(newList, numbers, arrays)},
			   bound - 1);
  
  return evaluateList(returnValue, numbers, {arrays[0], r});
}

Array basic_array([int nz,int na], int [nz] numbers, Array[na] arrays){
    ListExpression expression = sampleListExpression(UNROLL);
    minimize(listCost(expression));
    return evaluateList(expression, numbers, arrays);
}

int recursive_number([int nz,int na], int [nz] numbers, Array[na] arrays) {
  BooleanExpression predicate = sampleBooleanExpression(UNROLL);
  NumberExpression baseCase = sampleNumberExpression(UNROLL);
#ifdef FIRSTNUMBER  
  NumberExpression newNumber = sampleNumberExpression(UNROLL);
#endif
  ListExpression newList = sampleListExpression(UNROLL);
  NumberExpression returnValue = sampleNumberExpression(UNROLL);

  int cost = booleanCost(predicate) +
    numberCost(baseCase) +
    numberCost(newNumber) +
    listCost(newList) +
    numberCost(returnValue);
  
  bit extraReturn = ??;
  NumberExpression returnValue2;
  BooleanExpression recursivePredicate;
  if (extraReturn) {
    returnValue2 = sampleNumberExpression(UNROLL);
    recursivePredicate = sampleBooleanExpression(UNROLL);
    cost += numberCost(returnValue2) + booleanCost(recursivePredicate);    
  }

  minimize(cost);
  
  if (evaluateBoolean(predicate, numbers, arrays)) {
    return evaluateNumber(baseCase, numbers, arrays);
  }

  int [nz] numberArguments = {
#ifdef FIRSTNUMBER
    evaluateNumber(newNumber, numbers, arrays)
#endif
  };
  
  int r = recursive_number(numberArguments,
			   {evaluateList(newList, numbers, arrays)});
  if (!extraReturn || evaluateBoolean(recursivePredicate, numbers, arrays)) {
    return evaluateNumber(returnValue, {r
#ifdef FIRSTNUMBER
	  ,numbers[0]
#endif
	  }, arrays);
  } else {
    return evaluateNumber(returnValue2, {r
#ifdef FIRSTNUMBER
	  ,numbers[0]
#endif
	  }, arrays);
  }
}




void recursive_number_test_case([int l,int nz], int[nz] z, int [l] a, int t) {
  assert recursive_number(z,{list(a)}) == t;
}

void recursive_list_test_case([int l,int nz,int nt], int[nz] z, int [l] a, int[nt] t) {
  assert array_equal_vector(recursive_list(z,{list(a)},l+1), t);
}

harness void learn_to_count() {
  recursive_number_test_case({}, {}, 0);
  recursive_number_test_case({}, {9,2,9},2);
  recursive_number_test_case({}, {9,9,9},3);
  recursive_number_test_case({}, {8,9},1);
}

void basic_list_test_case([int l,int nz,int nt], int[nz] z, int [l] a, int[nt] t) {
  assert array_equal_vector(basic_array(z,{list(a)}), t);
}

// harness void learn_to_index() {
//   recursive_number_test_case({1}, {3,9,8}, 3);
//   recursive_number_test_case({2}, {1,9,8}, 9);
//   recursive_number_test_case({3}, {1,9,8}, 8);
// }



/* harness void learn_to_set() { */
/*   recursive_list_test_case({1,4}, {3,2,8}, {4,2,8}); */
/*   recursive_list_test_case({3,4}, {3,2,8}, {3,2,4}); */
/* } */

// harness void learn_to_insert() {
//   recursive_list_test_case({3},{1,9},{1,3,9});
//   recursive_list_test_case({3},{1,2,2},{1,2,2,3});
//   recursive_list_test_case({9},{},{9});
// }
// harness void learn_to_sort(){
//   recursive_list_test_case({},{2,9,1,3},{1,2,3,9});
//   //  recursive_list_test_case({},{},{});
// }

/* harness void learn_swap(){ */
/*     basic_list_test_case({1,2},{9,2},{2,9}); */
/*     basic_list_test_case({2,3},{5,4,6},{5,6,4}); */
/* } */
