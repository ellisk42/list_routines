//pragma options "--bnd-int-range 10";

struct Array{
  int s;
  int [s] A;
}

struct Environment{
  int na;
  Array[na] arrays;
  int nz;
  int [nz] numbers;
}

Environment push_array(Environment e, Array a) {
  Environment newEnvironment =
    new Environment(nz = e.nz, numbers = e.numbers,
		    na = 2, arrays = {e.arrays[0], a});
  return newEnvironment;
}

Environment push_number(Environment e, int z) {
  Environment newEnvironment =
    new Environment(nz = 2, numbers = {e.numbers[0],z},
		    na = e.na, arrays = e.arrays);
  return newEnvironment;
}


bit array_equal(Array a,Array b) {
  if (a.s != b.s) return 0;
  for (int j = 0; j < a.s; j++)
    if (a.A[j] != b.A[j]) return 0;
  return 1;
}


Array concatenate(Array a1,Array a2) {
  Array a = new Array(s = a1.s + a2.s,A = a1.A);
  a.A[a1.s :: a2.s] = a2.A;
  return a;
}


Array concatenate3(Array a1,Array a2,Array a3) {
  assert a1 != null;
  assert a2 != null;
  assert a3 != null;
  /*  assert a1.s + a2.s + a3.s >= 0;*/
  int l = validate_number(validate_number(a1.s) + validate_number(a2.s) + validate_number(a3.s));
  int[l] x;
  x[0 :: a1.s] = a1.A;
  x[a1.s :: a2.s] = a2.A;
  x[(a2.s+a1.s) :: a3.s] = a3.A;
  return new Array(s = l,A = x);
}

Array cdr(Array a, ref bit s) {
  if (a.s == 0) {
    s = 0;
    return empty_list();
  }
  s = 1;
  return new Array(s = a.s-1, A = a.A[1 :: (a.s-1)]);
}

Array singleton(int n) {
  return new Array(s = 1,A = {n});
}

int car(Array a, ref bit s) {
  if (a.s > 0) {
    s = 1;
    return a.A[0];
  }
  s = 0;
  return 0;
}

Array cons(int z, Array a) {
  return concatenate(singleton(z), a);
}

Array empty_list() {
  return new Array(s = 0,A = {});
}

generator Array array_expression(Environment e, int d, ref bit success) {
  assert d > 0;

  success = 1;

  bit _s;
  if (??) { return empty_list(); }
  if (??) {
    Array a = cdr(e.arrays[0],_s);
    success = _s;
    return a;
  }
  if (??) {
    if (e.na < 2) {
      success = 0;
      return empty_list();
    }
    Array a = cdr(e.arrays[1],_s);
    success = _s;
    return a;
  }
  if (??) return e.arrays[0];
  if (??) {
    if (e.na < 2) {
      success = 0;
      return empty_list();
    }
    return e.arrays[1];
  }

  bit sz;
  int z = number_expression(e, d - 1, sz);
  if (??) {
    success = sz;
    return singleton(z);
  }
  bit sl;
  Array l1 = array_expression(e, d - 1, sl);

  if (??) {
    success = sl && sz;
    return cons(z,l1);
  }
  if (??) {
    l1 = cdr(l1,_s);
    success = sl && _s;
    return l1;
  }
  assert 0;
}

generator int number_expression(Environment e, int d, ref bit success) {
  assert d > 0;

  success = 1;
  
  if (??) { return ??; }
  if (??) { return e.numbers[0]; }
  if (??) {
    if (e.nz < 2) {
      success = 0;
      return 0;
    }
    success = 1;
    return e.numbers[1];
  }

  bit _s;
  if (??){
    int z = car(e.arrays[0],_s);
    success = _s;
    return z;
  }
  if (??){
    if (e.na < 2) {
      success = 0;
      return 0;
    }
    int z = car(e.arrays[1],_s);
    success = _s;
    return z;
  }
  if (??) return e.arrays[0].s;
  if (??){
    if (e.na < 2) {
      success = 0;
      return 0;
    }
    success = 1;
    return e.arrays[1].s;
  }
  
  /*  if (??) {
    Array l = array_expression(e, d - 1);
    return {| car(l) | l.s |};
    }*/
  if (??) {
    int z = number_expression(e, d - 1, _s);
    success = _s;
    return {| z+1 | z-1 |};
  }
  assert 0;
}

generator bit predicate(Environment e, int d, ref bit success) {
  assert d > 0;

  bit s1;
  bit s2;
  
  int z1 = number_expression(e, d - 1, s1);
  int z2 = number_expression(e, d - 1, s2);

  success = s1 && s2;

  return {| z1 == z2 | z1 > z2 | z1 >= z2 |};
}

Array recursive_list(Environment e) {
  bit s1,s2,s3,s4,s5,s6;
  bit p = predicate(e, UNROLL, s1);
  assert s1;
  if (p) {
    Array a = array_expression(e, UNROLL, s2);
    assert s2;
    return a;
  }
  // Recursive in a new environment
  Environment ep =
      new Environment(na = 1,
		      arrays = {array_expression(e, UNROLL, s3)},
		      nz = 2,
		      numbers = {number_expression(e, UNROLL, s4),
			  number_expression(e, UNROLL, s5)});
  assert s3 && s4 && s5;
  
  Array recursiveArray = recursive_list(ep);

  Environment epp = push_array(e, recursiveArray);
    
  Array a = array_expression(epp, UNROLL, s6);
  assert s6;
  return a;
}

int recursive_number(Environment e) {
  bit success;
  bit p = predicate(e, UNROLL, success);
  assert success;
  if (p) {
    int z = number_expression(e, UNROLL, success);
    assert success;
    return z;
  }
  bit s1,s2,s3;
  Environment ep = new Environment(na = 1,
				   arrays = {array_expression(e, UNROLL, s1)},
				   nz = 1,
				   numbers = {number_expression(e, UNROLL, s2)});
  assert s1 && s2;
  
  int zp = recursive_number(ep);

  Environment epp = push_number(e, zp);

  int return_value = number_expression(epp, UNROLL, s3);
  assert s3;
  return return_value;
}

void recursive_number_test_case([int l,int nz], int[nz] z, int [l] a, int t) {
  Array ar = new Array(s = l, A = a);
  Environment e = new Environment(nz = nz, numbers = z,
				  na = 1, arrays = {ar});
  assert recursive_number(e) == t;
}

void recursive_list_test_case([int l,int nz,int nt], int[nz] z, int [l] a, int[nt] t) {
  Array ar = new Array(s = l, A = a);
  Environment e = new Environment(nz = nz, numbers = z,
				  na = 1, arrays = {ar});
  assert array_equal(recursive_list(e), new Array(s = nt, A = t));
}
/*
harness void list_get() {
  recursive_number_test_case({1},{9,8},9);
  recursive_number_test_case({2},{9,8},8);
  recursive_number_test_case({2},{0,1,0},1);
  recursive_number_test_case({2},{1,4,3},4);
  recursive_number_test_case({3},{1,4,3},3);
  }*/

/*harness void list_set1() { recursive_list_test_case({1,5},{9,8},{5,8}); }
harness void list_set2() { recursive_list_test_case({1,3},{9,8},{3,8}); }
harness void list_set3() { recursive_list_test_case({2,5},{9,8},{9,5}); }
harness void list_set4() { recursive_list_test_case({2,3},{0,8,4},{0,3,4}); }*/

harness void insert1() { recursive_list_test_case({1,0},{2,4},{1,2,4}); }
harness void insert2() { recursive_list_test_case({3,0},{2,4},{2,3,4}); }
harness void insert3() { recursive_list_test_case({9,0},{2,4},{2,4,9}); }
