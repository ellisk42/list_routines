include "language.skh";
pragma options "--bnd-unroll-amnt 3 --bnd-arr1d-size 3 --bnd-arr-size 3 --bnd-inline-amnt 3";

//#define FIRSTNUMBER
//#define SECONDNUMBER

Array recursive_list([int nz,int na], int [nz] numbers, Array[na] arrays, int bound) {
  int cost = 0;
  bit additionalBaseCase = ??;

  BooleanExpression predicate = sampleBooleanExpression(UNROLL);
  ListExpression baseCase = sampleListExpression(UNROLL);
  cost += booleanCost(predicate) + listCost(baseCase);

  BooleanExpression predicate2;
  ListExpression baseCase2;
  if (additionalBaseCase) {
    predicate2 = sampleBooleanExpression(UNROLL);
    baseCase2 = sampleListExpression(UNROLL);
    cost += booleanCost(predicate2) + listCost(baseCase2);
  }  
#ifdef FIRSTNUMBER
  NumberExpression newNumber1 = sampleNumberExpression(UNROLL);
  cost += numberCost(newNumber1);
#endif
#ifdef SECONDNUMBER
  NumberExpression newNumber2 = sampleNumberExpression(UNROLL);
  cost += numberCost(newNumber2);
#endif
  ListExpression newList = sampleListExpression(UNROLL);
  ListExpression returnValue = sampleListExpression(UNROLL);
  cost += listCost(newList) + listCost(returnValue);

  minimize(cost);
  
  if (evaluateBoolean(predicate, numbers, arrays)) {
    return evaluateList(baseCase, numbers, arrays);
  }

  if (additionalBaseCase) {
    if (evaluateBoolean(predicate2, numbers, arrays)) {
      return evaluateList(baseCase2, numbers, arrays);
    }
  }

  if (bound < 1) { assert 0; return null; }

  int [nz] numberArguments = {
#ifdef FIRSTNUMBER
    evaluateNumber(newNumber1, numbers, arrays)
#endif
#ifdef SECONDNUMBER			      
			      , evaluateNumber(newNumber2, numbers, arrays)
#endif
  };
  
  Array r = recursive_list(numberArguments,
			   {evaluateList(newList, numbers, arrays)},
			   bound - 1);
  
  return evaluateList(returnValue, numbers, {arrays[0], r});
}

int recursive_number([int nz,int na], int [nz] numbers, Array[na] arrays) {
  BooleanExpression predicate = sampleBooleanExpression(UNROLL);
  NumberExpression baseCase = sampleNumberExpression(UNROLL);
  NumberExpression newNumber = sampleNumberExpression(UNROLL);
  ListExpression newList = sampleListExpression(UNROLL);
  NumberExpression returnValue = sampleNumberExpression(UNROLL);

  minimize(booleanCost(predicate) +
	   numberCost(baseCase) +
	   numberCost(newNumber) +
	   listCost(newList) +
	   numberCost(returnValue));
  
  if (evaluateBoolean(predicate, numbers, arrays)) {
    return evaluateNumber(baseCase, numbers, arrays);
  }

  int [nz] numberArguments = {evaluateNumber(newNumber, numbers, arrays)};
  
  int r = recursive_number(numberArguments,
			   {evaluateList(newList, numbers, arrays)});
  
  return evaluateNumber(returnValue, {numbers[0], r}, arrays);
}


void recursive_number_test_case([int l,int nz], int[nz] z, int [l] a, int t) {
  assert recursive_number(z,{list(a)}) == t;
}

void recursive_list_test_case([int l,int nz,int nt], int[nz] z, int [l] a, int[nt] t) {
  assert array_equal_vector(recursive_list(z,{list(a)},l+1), t);
}

/* harness void learn_to_index() { */
/*   recursive_number_test_case({1}, {3,9,8}, 3); */
/*   recursive_number_test_case({2}, {1,9,8}, 9); */
/*   recursive_number_test_case({3}, {1,9,8}, 8); */
/* } */


/* harness void learn_to_set() { */
/*   recursive_list_test_case({1,4}, {3,2,8}, {4,2,8}); */
/*   recursive_list_test_case({3,4}, {3,2,8}, {3,2,4}); */
/* } */

harness void learn_to_insert() {
  recursive_list_test_case({3},{1,9},{1,3,9});
  recursive_list_test_case({3},{1,2},{1,2,3});
  recursive_list_test_case({9},{},{9});
}
/* harness void learn_to_sort(){ */
/*   recursive_list_test_case({},{2,9,1},{1,2,9}); */
/*   //  recursive_list_test_case({},{},{}); */
/* } */
