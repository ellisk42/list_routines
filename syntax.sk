include "language.skh";
pragma options "--bnd-unroll-amnt 4 --bnd-arr1d-size 4 --bnd-arr-size 4";

Array recursive_list([int nz,int na], int [nz] numbers, Array[na] arrays) {
  BooleanExpression predicate = sampleBooleanExpression(UNROLL);
  ListExpression baseCase = sampleListExpression(UNROLL);

  /*  NumberExpression[nz] newNumbers;
  int zi = 0;
  repeat(nz){
    newNumbers[zi++] = sampleNumberExpression(UNROLL);
  }*/
  
  NumberExpression newNumber1 = sampleNumberExpression(UNROLL);
  NumberExpression newNumber2 = sampleNumberExpression(UNROLL);
  ListExpression newList = sampleListExpression(UNROLL);
  ListExpression returnValue = sampleListExpression(UNROLL);

  minimize(booleanCost(predicate) +
	   listCost(baseCase) +
	   numberCost(newNumber1) +
	   numberCost(newNumber2) +
	   listCost(newList) +
	   listCost(returnValue));
  
  if (evaluateBoolean(predicate, numbers, arrays)) {
    return evaluateList(baseCase, numbers, arrays);
  }

  int [nz] numberArguments = {evaluateNumber(newNumber1, numbers, arrays),
			      evaluateNumber(newNumber2, numbers, arrays)};
  
  Array r = recursive_list(numberArguments,
			   {evaluateList(newList, numbers, arrays)});
  
  return evaluateList(returnValue, numbers, {arrays[0], r});
}

int recursive_number([int nz,int na], int [nz] numbers, Array[na] arrays) {
  BooleanExpression predicate = sampleBooleanExpression(UNROLL);
  NumberExpression baseCase = sampleNumberExpression(UNROLL);
  NumberExpression newNumber = sampleNumberExpression(UNROLL);
  ListExpression newList = sampleListExpression(UNROLL);
  NumberExpression returnValue = sampleNumberExpression(UNROLL);

  minimize(booleanCost(predicate) +
	   numberCost(baseCase) +
	   numberCost(newNumber) +
	   listCost(newList) +
	   numberCost(returnValue));
  
  if (evaluateBoolean(predicate, numbers, arrays)) {
    return evaluateNumber(baseCase, numbers, arrays);
  }

  int [nz] numberArguments = {evaluateNumber(newNumber, numbers, arrays)};
  
  int r = recursive_number(numberArguments,
			   {evaluateList(newList, numbers, arrays)});
  
  return evaluateNumber(returnValue, {numbers[0], r}, arrays);
}


void recursive_number_test_case([int l,int nz], int[nz] z, int [l] a, int t) {
  assert recursive_number(z,{list(a)}) == t;
}

void recursive_list_test_case([int l,int nz,int nt], int[nz] z, int [l] a, int[nt] t) {
  assert array_equal_vector(recursive_list(z,{list(a)}), t);
}

/* harness void learn_to_index() { */
/*   recursive_number_test_case({1}, {3,9,8}, 3); */
/*   recursive_number_test_case({2}, {1,9,8}, 9); */
/*   recursive_number_test_case({3}, {1,9,8}, 8); */
/* } */


harness void learn_to_set() {
  recursive_list_test_case({1,4}, {3,2,8}, {4,2,8});
  recursive_list_test_case({3,4}, {3,2,8}, {3,2,4});
}
